\documentclass[a4paper,11pt]{article}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{hyperref}

\usepackage{amssymb,amsmath,amsthm,latexsym,epsfig,euscript,multicol}
\usepackage[utf8x]{inputenc}
\usepackage{xcolor, bm}
\usepackage{listings}

\lstdefinelanguage{Python}
{
  morekeywords={from, import, def, return},
  comment=[l]{\#},
  morestring=[b]",
  alsodigit={-},
  alsoletter={&},
}
\lstdefinestyle{py}{
  language=Python,                 % the language of the code
  backgroundcolor=\color{white},   % choose the background color; you must add
  basicstyle=\ttfamily\small,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  firstnumber=1,                % start line enumeration with line 1000
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=5,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=4,	                   % sets default tabsize to 2 spaces
  title=\lstname,                  % show the filename of files included with \lstinputlisting; also try caption instead of title
  numbers=none
}
\lstset{style=py}


\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

% Caracteres especiales
\def\A{\mathbb{A}}
\def\C{\mathbb{C}}
\def \N{\mathbb{N}}
\def \P{\mathbb{P}}
\def \Q{\mathbb{Q}}
\def \R{\mathbb{R}}
\def \Z{\mathbb{Z}}
\def \sen{\textrm{sen}}

\def\Np{$\N$}
\def\Zp{$\Z$}
\def\Qp{$\Q$}
\def\Rp{$\R$}
\def\Cp{$\C$}

\def\bb{\bm{b}}
\def\bu{\bm{u}}
\def\bv{\bm{v}}
\def\bx{\bm{x}}
\def\bA{\bm{A}}
\def\bB{\bm{B}}
\def\bD{\bm{D}}
\def\bE{\bm{E}}
\def\bM{\bm{M}}
\def\bT{\bm{T}}


\def\K{\textrm{K}}
\def\V{\textrm{V}}
\def\S{\textrm{S}}

\def\degres{$^\circ$}

\newcount\todno
\def\no{\global\advance\todno by 1 \the\todno}

\topmargin-2cm \vsize 29.5cm \hsize 21cm
\setlength{\textwidth}{16.75cm}\setlength{\textheight}{23.5cm}
\setlength{\oddsidemargin}{0.0cm}
\setlength{\evensidemargin}{0.0cm}


\theoremstyle{definition}
\newtheorem{ejer}{Ejercicio}
\newcommand{\bej}{\begin{ejer}}
\newcommand{\fej}{\end{ejer}}

\begin{document}

\centerline{{\small Universidad de Buenos Aires - Facultad de Ciencias Exactas y Naturales - Ciencias de Datos}}

\vskip 0.2cm

\hrule

\vskip 0.2cm

 \centerline{{\bf\Large{\sc Laboratorio de Datos}}}

 \vskip 0.2cm

 \centerline{\ttfamily Primer Cuatrimestre 2024}

\vskip 0.2cm

 \hrule

 \bigskip
 \centerline{\bf Práctica N$^\circ$ 1: Nociones básicas de Python y la biblioteca \lstinline{numpy}.}
 \bigskip

Como le dijo el Sr. Miyagi a Daniel, "\emph{\href{https://www.youtube.com/watch?v=tM-wKYKw0tI}{encerar... pulir}}". No se puede hacer ciencia de punta sin antes volver intuitivos los conceptos fundacionales de un lenguaje. Así que \emph{copien los comandos de esta guía a mano en una consola}, y traten de estimar qué van a devolver, antes de ejecutarlos.

Si ya instalaron el entorno de trabajo que sugiere el \lstinline|README.md|, pueden lanzar una consola adecuada ejecutando \lstinline|source venv/bin/activate && python|.

\begin{enumerate}
\item
Realizar las siguientes operaciones básicas en Python.

\begin{lstlisting}
2 + 2
a = 2
b = 5
a**3
16 %% 5  # probar con otros numeros para entender que significa
2 * a**2 + 0.5 * b + (a + b) / 2

\item Interpretar las siguientes operaciones l\'ogicas entre variables booleanas y predecir el resultado antes de probar en la consola.
\begin{lstlisting}
a = True
b = False
a == b
a | b
a == (not b)
\end{lstlisting}

\item Antes de probar en la consola, piense que van a dar estas operaciones.
\begin{lstlisting}
a, b, c = 3, 4, 2
a > b
a <= b
a != b
a == b
not(a > b)
((c > a) or (10 * c > b)) and not(b / a > c)
\end{lstlisting}

\item Bonus: Abra la documentación de Python y lea sobre \href{https://docs.python.org/es/3/library/stdtypes.html\#tuples}{tuplas}.


\item \textbf{Listas.}
Las listas permiten guardar valores de distintos tipos en forma ordenada y acceder a los distintos elementos por su índice, comenzando desde 0.
\begin{lstlisting}
s = [1, 2, 3.0, "hola", 7 + 3]
s, s[0], s[1], s[-1]
\end{lstlisting}


\item \textbf{Vectores.}
Para trabajar con vectores en Python (y en general para todo tipo de operaciones matemáticas) vamos a usar el paquete \lstinline{numpy}. Para eso importamos primero la biblioteca \lstinline{numpy} y definimos vectores con el comando \lstinline{np.array}. Ejecutar el siguiente código y observar los resultados.

\begin{lstlisting}
import numpy as np
v = np.array([1,2,3])
w = np.array([1.2, 7, np.pi])
v, w, v + w
\end{lstlisting}

\item \textbf{La magia de Numpy} La biblioteca Numpy reproduce muchas funcionalidades de Matlab. La mayoría de las operaciones con vectores de Numpy se hacen coordenada a coordenada. Esto permite en muchos casos evitar usar ciclos o ciclos anidados y realizarlos con un solo comando.

Ejecutar los siguientes comandos e interpretar los resultados.

\begin{lstlisting}
np.set_printoptions(precision=2, suppress=True)
v = np.array([1,2,np.e,7])
w = np.array([1.2, np.pi, 4, 5])
for expr in [
    'v', 'w', 'v + w', 'v ** 2', 'v % 2', 'np.sum(v)', 'np.sqrt(w)', 'v > 3', 'w < 3.5'
]:
    print(f"{expr:11s} == {eval(expr)}")
\end{lstlisting}

\item Bonus: descrifrar qué magia hace la
\href{https://docs.python.org/es/3.11/tutorial/inputoutput.html\#tut-f-strings}{f-string} que recibe como argumento \lstinline{print}. ¿Y eso de \href{https://docs.python.org/es/3.11/library/functions.html\#eval}{eval}?

\item Las operaciones lógicas \lstinline{or} y \lstinline{and} no se pueden aplicar a vectores. Debemos usar los símbolos \lstinline{|} (or) y \lstinline{&} (and).
\begin{lstlisting}
(v > 3) | (w < 3.5)
(v > 3) & (w < 3.5)
\end{lstlisting}

\item ¿Cómo se puede aplicar \lstinline{not} a un vector de variables booleanas ($x \in \{\text{True, False}\}$)? Pueden probar algunas ideas o buscar la respuesta en Internet.

\item Algunos comandos pueden dar resultados inesperados. Intenten adivinar cuál va a ser el resultado de cada comando.
\begin{lstlisting}
v = np.array([1,2,np.e,7])
w = np.array([1.2, np.pi, 4, 5])
z = np.array([0,1])
v * w
v+2
v+z
\end{lstlisting}

\item Explorar estas distintas formas de extraer información de un vector.
\begin{lstlisting}[language=Python]
v = np.array([1, 2, np.e, 7, 5])
v[0], v[1], v[-1]  # funcionara `v[-2]`?
v[[0, 3]]
v[0:3], v[0:1]
\end{lstlisting}

\item También podemos seleccionar los elementos que cumplan alguna propiedad.
\begin{lstlisting}
v = np.array([1, 2, np.e, 7, 5])
w = np.array([1, 0, 2, 5, 0])
v[v > 2]
v[w != 0]
\end{lstlisting}

\item \textbf{Matrices} Las matrices se definen en numpy como arrays de filas. Las operaciones usuales se realizan coordenada a coordenada al igual que con vectores.
Verificar los resultados de los siguientes comandos.

\begin{lstlisting}
A = np.array([[3, 2, 2], [-1, 0, 1], [-2, 2, 4]])
B = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
C = np.array([[0, 1, -1], [5, -2, 1]])
A + B
A * B
C**2  # bonus: pruebe con np.
\end{lstlisting}

\item El producto usual de matrices se realiza con el comando \lstinline{@}. \lstinline|A.T| es la transpuesta de A. Verificar los resultados de los siguientes comandos.
\begin{lstlisting}
A @ B
B @ C
B.shape, C.shape
B @ C.T
\end{lstlisting}

\end{enumerate}
\textbf{\large Funciones}

Las funciones son bloques de código organizado que se usan para realizar tares específicas. Reciben un input (un número o una variable, por ejemplo) y devuelven un output. Los inputs van entre paréntesis y separados por una coma, si hay más de uno. Muchas funciones están disponibles en la biblioteca estándar de Python, otras estás agrupadas en distintas bibliotecas, como \lstinline{numpy} que agrupa una gran cantidad de funciones matemáticas. El objetivo de estos ejercicios es familiarizarse con varias funciones básicas de Python.

\begin{enumerate}[resume]
\item Ejecutar estas operaciones en la consola para entender qué hacen las funciones de numpy:
\begin{lstlisting}
a = np.sqrt(2)
a
np.round(a)
np.round(a, 2)
np.info(np.round)
np.info(np.ceil)
\end{lstlisting}

\item Muchas funciones de \lstinline{numpy} se pueden aplicar también en arrays:
\begin{lstlisting}
v = np.array([a, a**2, a**3, a**(.5)])
np.floor(v)
\end{lstlisting}

\item Explorar las funciones \lstinline{np.max()}, \lstinline{np.min()}, \lstinline{np.sum()}, \lstinline{np.mean()} y \lstinline{np.sort()} aplicadas al vector $v$ del ejercicio anterior. ¿Qué hace cada una?

\item Definir los siguientes vectores como arrays de \lstinline{numpy}:
\begin{align*}
\text{alturas\_cm} &= (180, 178, 154, 202), \\
\text{frutas} &= (\text{"banana"}, \text{"pera"}, \text{"durazno"}).
\end{align*}

¿Cuáles funciones del ejercicio anterior se pueden aplicar a cada uno de estos vectores? Verifiquen su respuesta.


\item Utilizando solo las operaciones y funciones vistas en los ejercicios anteriores, escribir códigos de una sola linea para las siguientes funciones matemáticas.
\begin{enumerate}
\item $\|v\|_2 = \sqrt{v_1^2 + v_2^2 + \dots + v_n^2} = \sqrt{\sum_{i=1}^n v_i^2}$
\item $\|v - w\|_2$
\item $\langle v, w\rangle = v_1 \cdot w_1 + v_2 \cdot w_2 + \dots + v_n \cdot w_n = \sum_{i=1}^n v_i \cdot w_i$
\end{enumerate}

\item En Python podemos definir nuestras propias funciones utilizando \lstinline{def}. ¿Qué hace la siguiente función? ¿Qué resultados esperan al aplicar la función a los vectores $v_0$ y $v_1$?
\begin{lstlisting}
def todosPositivos(v):
    return np.all(v > 0)


v0 = np.array([3, 4])
v1 = np.array([3, 5, -1, 1])
for i, v in enumerate([v0, v1]):
    assert todosPositivos(v), f"No todos los elementos son positivos en v{i}"
\end{lstlisting}

\item Definir una función que calcule la norma-2 de un vector y verificarla en los vectores $v_0$ y $v_1$ del ejercicio anterior.

\item Usar las funciones \lstinline{np.argmin()} y \lstinline{np.argmax()} con el vector de alturas definido anteriormente. Interpretar qué hace cada una. Realizar otro experimento para comprobarlo.

\item Reproducir estos usos de la función \lstinline{np.random.choice()} e interpretar qué hace.
\begin{lstlisting}
x = np.array(["cara", "ceca"])
s = np.random.choice(x, size=10)
print(s)
y = np.array([1,2,3,4,5,6])
t = np.random.choice(y, size=10)
print(t)
u = np.random.choice(y, size=4, replace=False)
print(u)
\end{lstlisting}

¿Para qué sirve el parámetro \lstinline{replace=False}? Realicen otras pruebas para verificarlo. Comparen con `random.choices` y `random.sample` de la biblioteca estándar de Python.

\item {\textbf{Ley de los grandes números.}} Esta ley asegura que si tiramos $n$ veces una moneda, el promedio de veces que sale cara tiende a $1/2$ cuando $n$ tiende a infinito.
Simular 10 lanzamientos de una moneda y calcular el promedio de veces que sale cara. Repetir para $n = 1000$ y $n = 100.000$.

%\item Bonus: Plantee al menos tres formas distintas de hacerlo; al menos una de ellas usando sólo tipos de datos nativos (lista, tupla, diccionario, et cetera).

\item Se tira $n$ veces una moneda. Intentar predecir, si existen, los siguientes límites cuando $n$ tiene a infinito y verificar la intuición mediante simulaciones.

\begin{enumerate}
\item La cantidad de caras dividido por la cantidad de cecas.
\item La cantidad de caras menos la cantidad de cecas.
\item La cantidad de caras menos la cantidad de cecas, divido por la cantidad total de tiradas.
\item Considerando las veces que salieron tres caras seguidas, el promedio de veces que en la siguiente tirada sale nuevamente cara.
\end{enumerate}



\end{enumerate}

\textbf{\large Archivos de datos}

\begin{enumerate}[resume]
\item La biblioteca \lstinline{Pandas} nos permite trabajar fácilmente con archivos de datos.

\begin{enumerate}
\item Leer el archivo \lstinline{casos_coronavirus.csv}.
\item Graficar la curva de casos por día.
\item Graficar la curva de casos acumulados.
\item Definir $log\_cum\_casos$ como el logaritmo de la cantidad de casos acumulados y graficar en función de la cantidad de días transcurridos.
\item Estimar, tomando dos valores, la pendiente de la recta para los datos a partir del dia 30.
\item Graficar la recta estimada junto con los datos. ¿Consideran que es una buena estimación?
\end{enumerate}

Utilicen o modifiquen el siguiente código.

\begin{lstlisting}
import pandas as pd
import matplotlib.pyplot as plt


df = pd.read_csv("Datos/casos_coronavirus.csv")
df.info()
df["fecha"] = pd.to_datetime(df.fecha, format="%d-%m-%Y")
casos = df.set_index("fecha").confirmados_Nuevos

plt.plot(casos)
plt.show()
# Bonus: pueden rotar las etiquetas del eje X para que no se superpongan?

cum_casos = casos.cumsum()
plt.plot(cum_casos)
plt.show()

# Tomamos logaritmos para linealizar
plt.plot(np.log(cum_casos))
plt.show()

# Alternativamente, podemos mantener los datos "al natural" y cambiar la _escala_ del eje y.
plt.plot(cum_casos), plt.yscale("log")
plt.show()
\end{lstlisting}

Vamos a ver más sobre la biblioteca \lstinline{pandas} y data frames en la próxima clase. En este ejemplo, convertimos los datos a arrays de numpy para utilizar las herramientas de los ejercicios anteriores.

\end{enumerate}

\end{document}
